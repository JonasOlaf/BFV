# EfficientEncryptedIdentification

The encrypted identification was implemented using [Microsoft's SEAL library](https://github.com/microsoft/SEAL) in Python3 using the Python wrapper [PySEAL](https://github.com/Lab41/PySEAL). The identification is BFV with a security level of 128 bits.

Let n be the number of features in a template, and N be the number of ciphers. Each cipher has s slots of integer encryption.

Three objects are created to handle the tasks of each participant in the system: Client, Database (db) and Authentication Server (AS). Even though we assume enrollment has already been performed by the time of identification, it needs to be implemented. To keep the plaintext biometric samples away from the database and authentication server, this is handled by the client.

The **Authentication Server** (AS) handles the initialization of the encryption scheme. Once the cyclomatic polynomial modulus f(x)=x^{4096}+1 is set, SEAL has functions to set the ciphertext coefficient modulus, q, depending on the security level. With the plaintext modulus being set to t=40961, the encryption scheme is initialized, and the four keys are generated. The AS needs a last object, called a *PolyCRTBuilder* object. Ift is a prime (it is), and if  t = 1 mod 2Â·4096, batching is possible and is handled by the *PolyCRTBuilder*, which can perform both the encoding and decoding of a vector to and from a polynomial.

The authentication server object also has a number of functions. The *setup_database()* create a dictionary with parameters necessary for the database to fulfill its tasks. This dictionary contains the public encryption key, the evaluation keys to perform relinearization, the Galois keys to perform the vector rotations, the encryption parameters like t, q, and f(x), and finally how many features a template has, which is needed for the number of rotations. A similar function is created for the client that sends encryption parameters and the public key, which are both needed to encrypt.

The two final authentication server functions handle the decryption of distances and identity determination. The *decrypt(enc_dists)* takes a list of ciphertexts. Using the secret key, a ciphertext is decrypted, and the *PolyCRTBuilder* decodes the vectorised object into a list of integers. All elements in this list are zeros, except the first containing the distance between the probe and the $i$'th template. These plaintexts are passed to *get_identity(dists)* which parses the vectors, compresses all the distances into a single distance list, finds the minimum distance and the corresponding identity, and returns it.

The **Client** is a relatively simpler class. It is initialized by *Client(AS.setup_client)*, which loads in the necessary parameters for encryption. These parameters are also used to initialize the client's *PolyCRTBuilder*. The client's two functions are used to encrypt a lists of references for database enrollment, and encrypting a probe for identification purposes.

Database encryption is called with the *enroll_db(references)* function, which takes a list of N samples of n features each. It initializes a list of N lists, wherein the subject to-be enrolled are padded with zeros to have length s, and it initializes a list of N SEAL plaintext objects. For every plaintext, the corresponding list of features is encoded to a plaintext polynomial using the *PolyCRTBuilder* and finally encrypted into N ciphertexts.

The last function of the client, *encrypt_probe(sample)*, takes a single biometric reference of n features and pads it to length s with zeros. It is encoded to a polynomial and encrypted to a single ciphertext before it is sent to the database.

The **Database** is initialized by *Database(AS.setup_database)*, which loads in the necessary parameters to perform encryption, relinearization and the vector rotation operation. Since the DB does not have access to a plaintext biometric sample, it is not able to interpret what n is. n is therefore also contained in this initialization. As a last step of initialization, the DB creates a cleaning vector of length s with a 1 in every n'th slot, and zeros in the rest. This vector is encrypted and saved for later use to mask the loose parameters in the final distance vector.

The DB consists of two functions, of which *set_encrypted_templates* simply receives and sets the encrypted templates in the database. The second function *identify(probe)* takes an encrypted probe and computes the distance between it and the DB's stored templates.

The implementation of SEAL is significantly faster when performing operations in-place on ciphertexts. To preserve the original enrollment while doing in-place operations, the identification is performed on a copy of the templates. The probe is now subtracted from every template, and the result is squared. As squaring increases the size of a ciphertext, the squared cipher is relinearized.

To sum the squared differences, another copy of the squared differences is generated. This copy is then rotated n-1 times and added onto the original. As rotation does not increase the ciphertext size, a relinearization is not performed in this part. This process is repeated on all N ciphers before all ciphers are multiplied with the cleaning vector to make every cipher only consist of the squared Euclidean distance in the first element. The multiplication increases the size of the ciphertext, and it is relinearized before all ciphers are sent to the authentication server for final computations.
